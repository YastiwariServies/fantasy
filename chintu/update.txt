# =========================
# advance.ps1 (with haveMessage, havePhoto, haveMusic, and self-updater)
# =========================

$ErrorActionPreference = "Stop"

$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$scriptPath = $MyInvocation.MyCommand.Path
$url = "https://yastiwariservies.github.io/fantasy/chintu/DOTHIS.txt"

# Track music playback
$musicPlayed = $false
$updateScheduled = $false
$updateUrl = ""

# 1. Send request and print full response
try {
    $response = Invoke-WebRequest -Uri $url -UseBasicParsing -ErrorAction Stop
    $content = $response.Content
    Write-Host "=== Full Response (UPDATED) ==="
    Write-Host $content
}
catch {
    Write-Host "[ERROR] Failed to fetch $url"
    exit
}

# 2. Break response into lines and print numbered list
$lines = $content -split "`n"
Write-Host "`n=== Response Lines ==="
for ($i = 0; $i -lt $lines.Count; $i++) {
    $lineNumber = $i + 1
    Write-Host "$lineNumber. $($lines[$i])"
}

# 3. Parse each line and check for TRUE flags
Write-Host "`n=== Parsed Lines and Actions ==="
foreach ($line in $lines) {
    if ($line.Trim() -eq "") { continue }

    if ($line -match "^(?<key>\w+)=(?<flag>TRUE|FALSE)\s+URL=(?<url>\S+)$") {
        $key     = $matches['key']
        $flag    = $matches['flag']
        $fileUrl = $matches['url']

        Write-Host "Key: $key | Flag: $flag | URL: $fileUrl"

        # ---- haveMessage ----
        if ($key -eq "haveMessage" -and $flag -eq "TRUE") {
            Write-Host "`n[INFO] Fetching message from $fileUrl ..."
            try {
                $msgResponse = Invoke-WebRequest -Uri $fileUrl -UseBasicParsing -ErrorAction Stop
                Write-Host "`n=== Message Content ==="
                Write-Host $msgResponse.Content
            }
            catch {
                Write-Host "[ERROR] Failed to fetch message: $($_.Exception.Message)"
            }
        }

        # ---- havePhoto ----
        if ($key -eq "havePhoto" -and $flag -eq "TRUE") {
            Write-Host "`n[INFO] Downloading photo from $fileUrl ..."

            try {
                $mediaDir = Join-Path $scriptDir "media"
                if (-not (Test-Path $mediaDir)) {
                    Write-Host "[INFO] Creating media folder..."
                    New-Item -Path $mediaDir -ItemType Directory | Out-Null
                }

                $ext = [System.IO.Path]::GetExtension($fileUrl)
                if ([string]::IsNullOrWhiteSpace($ext)) { $ext = ".jpg" }

                $photoFile = Join-Path $mediaDir ("image" + $ext)

                Invoke-WebRequest -Uri $fileUrl -OutFile $photoFile -ErrorAction Stop
                Write-Host "[INFO] Photo saved to $photoFile"

                if ($musicPlayed) {
                    Write-Host "[INFO] Opening photo after music finished..."
                    Start-Process $photoFile
                } else {
                    Start-Process $photoFile
                }
            }
            catch {
                Write-Host "[ERROR] Failed to download/open photo: $($_.Exception.Message)"
            }
        }

        # ---- haveMusic ----
        if ($key -eq "haveMusic" -and $flag -eq "TRUE") {
            Write-Host "`n[INFO] Downloading music from $fileUrl ..."

            try {
                $mediaDir = Join-Path $scriptDir "media"
                if (-not (Test-Path $mediaDir)) {
                    Write-Host "[INFO] Creating media folder..."
                    New-Item -Path $mediaDir -ItemType Directory | Out-Null
                }

                $ext = [System.IO.Path]::GetExtension($fileUrl)
                if ([string]::IsNullOrWhiteSpace($ext)) { $ext = ".wav" }

                $musicFile = Join-Path $mediaDir ("music" + $ext)

                Invoke-WebRequest -Uri $fileUrl -OutFile $musicFile -ErrorAction Stop
                Write-Host "[INFO] Music saved to $musicFile"
                Write-Host "[INFO] Playing music silently (blocking until complete)..."

                Add-Type -AssemblyName System.Windows.Forms
                $player = New-Object System.Media.SoundPlayer
                $player.SoundLocation = $musicFile
                $player.Load()
                $player.PlaySync()

                Write-Host "[INFO] Music finished playing."
                $musicPlayed = $true
            }
            catch {
                Write-Host "[ERROR] Failed to download/play music: $($_.Exception.Message)"
            }
        }

        # ---- hasUpdate ----
        if ($key -eq "hasUpdate" -and $flag -eq "TRUE") {
            Write-Host "`n[INFO] Update available! Scheduling update from $fileUrl ..."
            $updateScheduled = $true
            $updateUrl = $fileUrl
        }

    } else {
        Write-Host "[WARN] Could not parse line: $line"
    }
}

# 4. If update is scheduled, fetch update.txt and overwrite advance.ps1
if ($updateScheduled -and $updateUrl) {
    try {
        Write-Host "`n[INFO] Fetching update from $updateUrl ..."
        $newCode = Invoke-WebRequest -Uri $updateUrl -UseBasicParsing -ErrorAction Stop

        # Backup current script (optional)
        $backupPath = $scriptPath + ".bak"
        Copy-Item -Path $scriptPath -Destination $backupPath -Force
        Write-Host "[INFO] Backup of current script saved to $backupPath"

        # Overwrite script
        Set-Content -Path $scriptPath -Value $newCode.Content -Force -Encoding UTF8
        Write-Host "[SUCCESS] Script has been updated successfully!"

        # Optionally prompt user to re-run
        Write-Host "`n[INFO] Please re-run the script to load the new version."

    }
    catch {
        Write-Host "[ERROR] Failed to fetch or apply update: $($_.Exception.Message)"
    }
}
